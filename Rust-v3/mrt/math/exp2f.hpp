#pragma once
#include "detail.hpp"
namespace crt::math {
    struct ExpBase {
        // Base = e
        static constexpr int MID_BITS = 5;
        static constexpr int MID_MASK = (1 << MID_BITS) - 1;
        // log2(e) * 2^5
        static constexpr double LOG2_B = 0x1.71547652b82fep+0 * (1 << MID_BITS);
        // High and low parts of -log(2) * 2^(-5)
        static constexpr double M_LOGB_2_HI = -0x1.62e42fefa0000p-1 / (1 << MID_BITS);
        static constexpr double M_LOGB_2_LO = -0x1.cf79abc9e3b3ap-40 / (1 << MID_BITS);
        // Look up table for bit fields of 2^(i/32) for i = 0..31, generated by Sollya
        // with:
        // > for i from 0 to 31 do printdouble(round(2^(i/32), D, RN));
        static constexpr int64_t EXP_2_MID[1 << MID_BITS] = {
            0x3ff0000000000000, 0x3ff059b0d3158574, 0x3ff0b5586cf9890f, 0x3ff11301d0125b51, 0x3ff172b83c7d517b, 0x3ff1d4873168b9aa, 0x3ff2387a6e756238,
            0x3ff29e9df51fdee1, 0x3ff306fe0a31b715, 0x3ff371a7373aa9cb, 0x3ff3dea64c123422, 0x3ff44e086061892d, 0x3ff4bfdad5362a27, 0x3ff5342b569d4f82,
            0x3ff5ab07dd485429, 0x3ff6247eb03a5585, 0x3ff6a09e667f3bcd, 0x3ff71f75e8ec5f74, 0x3ff7a11473eb0187, 0x3ff82589994cce13, 0x3ff8ace5422aa0db,
            0x3ff93737b0cdc5e5, 0x3ff9c49182a3f090, 0x3ffa5503b23e255d, 0x3ffae89f995ad3ad, 0x3ffb7f76f2fb5e47, 0x3ffc199bdd85529c, 0x3ffcb720dcef9069,
            0x3ffd5818dcfba487, 0x3ffdfc97337b9b5f, 0x3ffea4afa2a490da, 0x3fff50765b6e4540,
        };
    };

    constexpr uint32_t exval1 = 0x3b42'9d37U;
    constexpr uint32_t exval2 = 0xbcf3'a937U;
    constexpr uint32_t exval_mask = exval1 & exval2;

    inline float exp2f(float x) {
        using FPBits = typename detail::FPBits<float>;
        FPBits xbits(x);

        uint32_t x_u = xbits.uintval();
        uint32_t x_abs = x_u & 0x7fff'ffffU;

        // |x| < 2^-25
        if (detail::unlikely(x_abs <= 0x3280'0000U)) {
            return 1.0f + x;
        }

        // // When |x| >= 128, or x is nan
        if (detail::unlikely(x_abs >= 0x4300'0000U)) {

            // x >= 128
            if (!xbits.get_sign()) {
                // x is finite
                if (x_u < 0x7f80'0000U) {
                    int rounding = detail::get_round();
                    if (rounding == detail::FE_DOWNWARD_DEF || rounding == detail::FE_TOWARDZERO_DEF)
                        return static_cast<float>(FPBits(FPBits::MAX_NORMAL));
                }
                // x is +inf or nan
                return x + FPBits::inf().get_val();
            }
            // x <= -150
            if (x_u >= 0xc316'0000U) {
                // exp(-Inf) = 0
                if (xbits.is_inf())
                    return 0.0f;
                // exp(nan) = nan
                if (xbits.is_nan())
                    return x;
                if (detail::get_round() == detail::FE_UPWARD_DEF)
                    return FPBits(FPBits::MIN_SUBNORMAL).get_val();
                return 0.0f;
            }
        }

        // Check exceptional values.
        if (detail::unlikely(x_u & exval_mask)) {
            if (detail::unlikely(x_u == exval1)) { // x = 0x1.853a6ep-9f
                if (detail::get_round() == detail::FE_TONEAREST_DEF)
                    return 0x1.00870ap+0f;
            } else if (detail::unlikely(x_u == exval2)) { // x = -0x1.e7526ep-6f
                if (detail::get_round() == detail::FE_TONEAREST_DEF)
                    return 0x1.f58d62p-1f;
            }
        }

        float kf = detail::nearest_integer(x * 32.0f);
        double dx = detail::multiply_add(-0x1.0p-5f, kf, x);

        int k = static_cast<int>(kf);

        int64_t exp_hi = static_cast<int64_t>(k >> ExpBase::MID_BITS) << detail::FloatProperties<double>::MANTISSA_WIDTH;

        int64_t mh_bits = ExpBase::EXP_2_MID[k & ExpBase::MID_MASK] + exp_hi;
        double mh = detail::FPBits<double>(uint64_t(mh_bits)).get_val();

        constexpr double COEFFS[5] = {0x1.62e42fefa39efp-1, 0x1.ebfbdff8131c4p-3, 0x1.c6b08d7061695p-5, 0x1.3b2b1bee74b2ap-7, 0x1.5d88091198529p-10};
        double dx_sq = dx * dx;
        double c1 = detail::multiply_add(dx, COEFFS[0], 1.0);
        double c2 = detail::multiply_add(dx, COEFFS[2], COEFFS[1]);
        double c3 = detail::multiply_add(dx, COEFFS[4], COEFFS[3]);
        double p = detail::multiply_add(dx_sq, c3, c2);

        return float(detail::multiply_add(p, dx_sq * mh, c1 * mh));
    }
} // namespace crt::math